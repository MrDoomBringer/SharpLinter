<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#

var lintFile = Directory.GetParent(this.Host.TemplateFile).Parent.GetFiles("*.js").SingleOrDefault();
if (lintFile == null)
{
	throw new FileNotFoundException("Unable to locate JSLint.js file.");
}

var settings = new List<JsonProperty>();

using (var thing = lintFile.OpenText())
{
	string line;
	while ((line = thing.ReadLine()) != null)
	{
		if (line.EndsWith("exports.bool = {"))
		{
			while ((line = thing.ReadLine()) != null)
			{
				if (line.Trim() == "};")
				{
					// End of the json block, break out.
					break;
				}

				// This is the start of the JSLint configuration options.
				// From here on we're looking for individual configuration
				// options which can be present in a .jshintrc file.
				if (line.Contains("*") || line.Contains("{") || line.Contains("}")) continue;

				// This is an actual setting option, peel it out.
				line = line.Trim();
				if (!line.Contains(":")) continue;
				
				var name = line.Substring(0, line.IndexOf(':'));

				settings.Add(specialOptions.ContainsKey(name)
					? new JsonProperty(name, FirstLetterToUpper(name), specialOptions[name].Item1.ToString(), specialOptions[name].Item2.ToString())
					: new JsonProperty(name, FirstLetterToUpper(name), "bool", "true"));
			}
		}
		else if (line.EndsWith("exports.val = {"))
		{
			while ((line = thing.ReadLine()) != null)
			{
				if (line.Trim() == "};")
				{
					// End of the json block, break out.
					break;
				}

				// This is the start of the JSLint configuration options.
				// From here on we're looking for individual configuration
				// options which can be present in a .jshintrc file.
				if (line.Contains("*") || line.Contains("{") || line.Contains("}")) continue;

				// This is an actual setting option, peel it out.
				line = line.Trim();
				if (!line.Contains(":")) continue;
				
				var name = line.Substring(0, line.IndexOf(':'));

				settings.Add(specialOptions.ContainsKey(name)
					? new JsonProperty(name, FirstLetterToUpper(name), specialOptions[name].Item1.ToString(), specialOptions[name].Item2.ToString())
					: new JsonProperty(name, FirstLetterToUpper(name), "bool", "true"));
			}
		}
	}
}
#>
using Newtonsoft.Json;

namespace SharpLinter.Config
{
	internal class LintConfig
	{
<#foreach (var property in settings) {#>
		/// <summary>
		/// JSON setting for <#=property.JsonName#>.
		/// </summary>
		[JsonProperty("<#=property.JsonName#>")]
		public <#=property.Type#> <#=property.Name#> { get; set; } = <#=property.DefaultValue#>;

<#}#>	}
}
<#+
private static Dictionary<string, Tuple<Type, String>> specialOptions = new Dictionary<string, Tuple<Type, String>>
{
	{"maxerr", new Tuple<Type, String>(typeof(int), "50")},
	{"indent", new Tuple<Type, String>(typeof(int), "4")},
	{"maxparams", new Tuple<Type, String>(typeof(int), "0")},
	{"maxdepth", new Tuple<Type, String>(typeof(int), "0")},
	{"maxstatements", new Tuple<Type, String>(typeof(int), "0")},
	{"maxlen", new Tuple<Type, String>(typeof(int), "0")},
	{"maxcomplexity", new Tuple<Type, String>(typeof(int), "0")},
	{"shadow", new Tuple<Type, String>(typeof(string), "\"true\"")},
	{"unused", new Tuple<Type, String>(typeof(string), "\"true\"")},
	{"latedef", new Tuple<Type, String>(typeof(string), "\"true\"")},
	{"quotmark", new Tuple<Type, String>(typeof(string), "\"false\"")},
	{"globals", new Tuple<Type, String>(typeof(string[]), "null")},
};

internal class JsonProperty
{
	public JsonProperty(string jsonName, string name, string type, string defaultValue)
	{
		JsonName = jsonName;
		Name = name;
		Type = type;
		DefaultValue = defaultValue;
	}

	public string JsonName { get; private set; }
	public string Name { get; private set; }
	public string Type { get; private set; }
	public string DefaultValue { get; private set; }
}

public string FirstLetterToUpper(string str)
{
	if (str == null)
		return null;

	if (str.Length > 1)
		return char.ToUpper(str[0]) + str.Substring(1);

	return str.ToUpper();
}
#>